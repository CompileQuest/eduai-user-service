const { connect } = require("amqplib");
const config = require("./config");
const Consumer = require("./consumer");
const Producer = require("./producer");

class RabbitMQClient {
    constructor() {
        if (RabbitMQClient.instance) {
            return RabbitMQClient.instance;
        }

        this.isInitialized = false;
        this.producer = null;
        this.consumer = null;
        this.connection = null;
        this.producerChannel = null;
        this.consumerChannel = null;

        RabbitMQClient.instance = this;
    }

    static getInstance() {
        if (!RabbitMQClient.instance) {
            RabbitMQClient.instance = new RabbitMQClient();
        }
        return RabbitMQClient.instance;
    }

    async initialize() {
        if (this.isInitialized) {
            console.log("instance of rabbit client exited ", this.isInitialized);
            return;
        }

        try {
            this.connection = await connect(config.rabbitMQ.url);

            this.producerChannel = await this.connection.createChannel();
            this.consumerChannel = await this.connection.createChannel();

            const { queue: rpcQueue } = await this.consumerChannel.assertQueue(
                config.rabbitMQ.queues.rpcQueue,
                { exclusive: true }
            );

            this.producer = new Producer(this.producerChannel);
            this.consumer = new Consumer(this.consumerChannel, rpcQueue);

            this.consumer.consumeMessages();

            this.isInitialized = true;
            console.log("created a new instance of client rabbit");

        } catch (error) {
            console.log("RabbitMQ error...", error);
        }
    }

    async produce(data, correlationId, replyToQueue) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        return await this.producer.produceMessages(
            data,
            correlationId,
            replyToQueue
        );
    }
}

module.exports = RabbitMQClient.getInstance();
// config.js
module.exports = {
    rabbitMQ: {
        url: "amqp://mohd:mohd@localhost",
        queues: {
            rpcQueue: "user-to-auth-queue",
        },
    },
};
  const { Channel } = require("amqplib");
const MessageHandler = require("./messageHandler");

class Consumer {
    constructor(channel, rpcQueue) {
        this.channel = channel;
        this.rpcQueue = rpcQueue;
    }

    async consumeMessages() {
        console.log("Ready to consume messages...");

        this.channel.consume(
            this.rpcQueue,
            async (message) => {
                const { correlationId, replyTo } = message.properties;
                const operation = message.properties.headers.function;

                if (!correlationId || !replyTo) {
                    console.log("Missing some properties...");
                }
                console.log("Consumed", JSON.parse(message.content.toString()));
                await MessageHandler.handle(
                    operation,
                    JSON.parse(message.content.toString()),
                    correlationId,
                    replyTo
                );
            },
            {
                noAck: true,
            }
        );
    }
}

module.exports = Consumer;


const rabbitClient = require("./client");

class MessageHandler {
    static async handle(operation, data, correlationId, replyTo) {
        let response = {};

        const { num1, num2 } = data;

        console.log("The operation is", operation);

        switch (operation) {
            case "multiply":
                response = num1 * num2;
                break;

            case "sum":
                response = num1 + num2;
                break;

            default:
                response = 0;
                break;
        }

        // Produce the response back to the client
        await rabbitClient.produce(response, correlationId, replyTo);
    }
}

module.exports = MessageHandler;
const { Channel } = require("amqplib");

class Producer {
    constructor(channel) {
        this.channel = channel;
    }

    async produceMessages(data, correlationId, replyToQueue) {
        console.log("Responding with..", data);
        this.channel.sendToQueue(replyToQueue, Buffer.from(JSON.stringify(data)), {
            correlationId: correlationId,
        });
    }
}

module.exports = Producer;
